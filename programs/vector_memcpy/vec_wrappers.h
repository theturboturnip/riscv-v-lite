#ifndef CHERI_VECTOR_WRAPPERS
#define CHERI_VECTOR_WRAPPERS
#include <stdint.h>
#include <riscv_vector.h>

// This file is autogenerated by vector_intrinsic_gen.py
// It provides equivalents to RISC-V vector load/store instrinsics that are CHERI-compatible.
// Function names are prefixed with 'cheri_'

// The reason this is needed at all is because the vector intrinsics haven't been adjusted for CHERI support.
// This can be fixed by using inline assembly, but there's a catch.
// Inline assembly in CHERI-Clang (and also normal Clang trunk) will by default insert offsets in front of memory addresses
// e.g. 'vse8.v v8, 0(ca0)'
// RISC-V Vectors don't support offsets on loads/stores, and reject this.
// To get around this, we wrap each inline asm in a function, 
// and hardcode the address as '(ca0)' with no offset.
// This works because the first argument to each function is the pointer,
// and the RISC-V CHERI ABI puts that argument in the ca0 register every time.

// Define VEC_INTRIN(i) which calls the CHERI version if available
#if __has_feature(capabilities)
#define VEC_INTRIN(i) cheri_ ## i
#else
#define VEC_INTRIN(i) i
#endif // __has_feature(capabilities)

// Only generate CHERI versions if we're in CHERI
#if __has_feature(capabilities)

int cheri_vle8_v_u8mf8(const void* ptr, size_t vlen) {
    asm volatile(
        "vle8.v v1, (ca0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse8_v_u8mf8(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse8.v v1, (ca0)"
        : "=m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
        : // we specify input register directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle8_v_i8mf8(const void* ptr, size_t vlen) {
    asm volatile(
        "vle8.v v1, (ca0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse8_v_i8mf8(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse8.v v1, (ca0)"
        : "=m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
        : // we specify input register directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle8_v_u8mf4(const void* ptr, size_t vlen) {
    asm volatile(
        "vle8.v v1, (ca0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse8_v_u8mf4(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse8.v v1, (ca0)"
        : "=m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
        : // we specify input register directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle8_v_i8mf4(const void* ptr, size_t vlen) {
    asm volatile(
        "vle8.v v1, (ca0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse8_v_i8mf4(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse8.v v1, (ca0)"
        : "=m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
        : // we specify input register directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle16_v_u16mf4(const void* ptr, size_t vlen) {
    asm volatile(
        "vle16.v v1, (ca0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse16_v_u16mf4(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse16.v v1, (ca0)"
        : "=m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
        : // we specify input register directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle16_v_i16mf4(const void* ptr, size_t vlen) {
    asm volatile(
        "vle16.v v1, (ca0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse16_v_i16mf4(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse16.v v1, (ca0)"
        : "=m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
        : // we specify input register directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle8_v_u8mf2(const void* ptr, size_t vlen) {
    asm volatile(
        "vle8.v v1, (ca0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse8_v_u8mf2(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse8.v v1, (ca0)"
        : "=m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
        : // we specify input register directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle8_v_i8mf2(const void* ptr, size_t vlen) {
    asm volatile(
        "vle8.v v1, (ca0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse8_v_i8mf2(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse8.v v1, (ca0)"
        : "=m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
        : // we specify input register directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle16_v_u16mf2(const void* ptr, size_t vlen) {
    asm volatile(
        "vle16.v v1, (ca0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse16_v_u16mf2(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse16.v v1, (ca0)"
        : "=m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
        : // we specify input register directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle16_v_i16mf2(const void* ptr, size_t vlen) {
    asm volatile(
        "vle16.v v1, (ca0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse16_v_i16mf2(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse16.v v1, (ca0)"
        : "=m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
        : // we specify input register directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle32_v_u32mf2(const void* ptr, size_t vlen) {
    asm volatile(
        "vle32.v v1, (ca0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse32_v_u32mf2(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse32.v v1, (ca0)"
        : "=m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
        : // we specify input register directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle32_v_i32mf2(const void* ptr, size_t vlen) {
    asm volatile(
        "vle32.v v1, (ca0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse32_v_i32mf2(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse32.v v1, (ca0)"
        : "=m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
        : // we specify input register directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle8_v_u8m1(const void* ptr, size_t vlen) {
    asm volatile(
        "vle8.v v1, (ca0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse8_v_u8m1(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse8.v v1, (ca0)"
        : "=m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
        : // we specify input register directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle8_v_i8m1(const void* ptr, size_t vlen) {
    asm volatile(
        "vle8.v v1, (ca0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse8_v_i8m1(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse8.v v1, (ca0)"
        : "=m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
        : // we specify input register directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle16_v_u16m1(const void* ptr, size_t vlen) {
    asm volatile(
        "vle16.v v1, (ca0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse16_v_u16m1(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse16.v v1, (ca0)"
        : "=m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
        : // we specify input register directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle16_v_i16m1(const void* ptr, size_t vlen) {
    asm volatile(
        "vle16.v v1, (ca0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse16_v_i16m1(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse16.v v1, (ca0)"
        : "=m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
        : // we specify input register directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle32_v_u32m1(const void* ptr, size_t vlen) {
    asm volatile(
        "vle32.v v1, (ca0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse32_v_u32m1(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse32.v v1, (ca0)"
        : "=m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
        : // we specify input register directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle32_v_i32m1(const void* ptr, size_t vlen) {
    asm volatile(
        "vle32.v v1, (ca0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse32_v_i32m1(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse32.v v1, (ca0)"
        : "=m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
        : // we specify input register directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle8_v_u8m2(const void* ptr, size_t vlen) {
    asm volatile(
        "vle8.v v2, (ca0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse8_v_u8m2(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse8.v v2, (ca0)"
        : "=m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
        : // we specify input register directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle8_v_i8m2(const void* ptr, size_t vlen) {
    asm volatile(
        "vle8.v v2, (ca0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse8_v_i8m2(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse8.v v2, (ca0)"
        : "=m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
        : // we specify input register directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle16_v_u16m2(const void* ptr, size_t vlen) {
    asm volatile(
        "vle16.v v2, (ca0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse16_v_u16m2(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse16.v v2, (ca0)"
        : "=m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
        : // we specify input register directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle16_v_i16m2(const void* ptr, size_t vlen) {
    asm volatile(
        "vle16.v v2, (ca0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse16_v_i16m2(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse16.v v2, (ca0)"
        : "=m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
        : // we specify input register directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle32_v_u32m2(const void* ptr, size_t vlen) {
    asm volatile(
        "vle32.v v2, (ca0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse32_v_u32m2(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse32.v v2, (ca0)"
        : "=m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
        : // we specify input register directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle32_v_i32m2(const void* ptr, size_t vlen) {
    asm volatile(
        "vle32.v v2, (ca0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse32_v_i32m2(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse32.v v2, (ca0)"
        : "=m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
        : // we specify input register directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle8_v_u8m4(const void* ptr, size_t vlen) {
    asm volatile(
        "vle8.v v4, (ca0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse8_v_u8m4(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse8.v v4, (ca0)"
        : "=m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
        : // we specify input register directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle8_v_i8m4(const void* ptr, size_t vlen) {
    asm volatile(
        "vle8.v v4, (ca0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse8_v_i8m4(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse8.v v4, (ca0)"
        : "=m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
        : // we specify input register directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle16_v_u16m4(const void* ptr, size_t vlen) {
    asm volatile(
        "vle16.v v4, (ca0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse16_v_u16m4(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse16.v v4, (ca0)"
        : "=m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
        : // we specify input register directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle16_v_i16m4(const void* ptr, size_t vlen) {
    asm volatile(
        "vle16.v v4, (ca0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse16_v_i16m4(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse16.v v4, (ca0)"
        : "=m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
        : // we specify input register directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle32_v_u32m4(const void* ptr, size_t vlen) {
    asm volatile(
        "vle32.v v4, (ca0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse32_v_u32m4(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse32.v v4, (ca0)"
        : "=m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
        : // we specify input register directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle32_v_i32m4(const void* ptr, size_t vlen) {
    asm volatile(
        "vle32.v v4, (ca0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse32_v_i32m4(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse32.v v4, (ca0)"
        : "=m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
        : // we specify input register directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle8_v_u8m8(const void* ptr, size_t vlen) {
    asm volatile(
        "vle8.v v8, (ca0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse8_v_u8m8(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse8.v v8, (ca0)"
        : "=m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
        : // we specify input register directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle8_v_i8m8(const void* ptr, size_t vlen) {
    asm volatile(
        "vle8.v v8, (ca0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse8_v_i8m8(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse8.v v8, (ca0)"
        : "=m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
        : // we specify input register directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle16_v_u16m8(const void* ptr, size_t vlen) {
    asm volatile(
        "vle16.v v8, (ca0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse16_v_u16m8(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse16.v v8, (ca0)"
        : "=m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
        : // we specify input register directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle16_v_i16m8(const void* ptr, size_t vlen) {
    asm volatile(
        "vle16.v v8, (ca0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse16_v_i16m8(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse16.v v8, (ca0)"
        : "=m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
        : // we specify input register directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle32_v_u32m8(const void* ptr, size_t vlen) {
    asm volatile(
        "vle32.v v8, (ca0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse32_v_u32m8(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse32.v v8, (ca0)"
        : "=m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
        : // we specify input register directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle32_v_i32m8(const void* ptr, size_t vlen) {
    asm volatile(
        "vle32.v v8, (ca0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse32_v_i32m8(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse32.v v8, (ca0)"
        : "=m"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
        : // we specify input register directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}
#endif // __has_feature(capabilities)
#endif // CHERI_VECTOR_WRAPPERS