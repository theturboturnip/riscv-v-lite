#ifndef CHERI_VECTOR_WRAPPERS
#define CHERI_VECTOR_WRAPPERS
#include <stdint.h>
#include <riscv_vector.h>

// This file is autogenerated by vector_intrinsic_gen.py
// It provides equivalents to RISC-V vector load/store intrinsics that are CHERI-compatible.
// Function names are prefixed with 'cheri_'
// The reason this is needed at all is because the vector intrinsics haven't been adjusted for CHERI support.

// Define VEC_INTRIN(i) which calls the CHERI version if available
#if __has_feature(capabilities)
#define VEC_INTRIN(i) cheri_ ## i
#else
#define VEC_INTRIN(i) i
#endif // __has_feature(capabilities)

// Only generate CHERI versions if we're in CHERI
#if __has_feature(capabilities)

int cheri_vle8_v_u8mf8(const void* ptr, size_t vlen) {
    asm volatile(
        "vle8.v v1, (%0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse8_v_u8mf8(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse8.v v1, (%0)"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle8_v_i8mf8(const void* ptr, size_t vlen) {
    asm volatile(
        "vle8.v v1, (%0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse8_v_i8mf8(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse8.v v1, (%0)"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle8_v_u8mf4(const void* ptr, size_t vlen) {
    asm volatile(
        "vle8.v v1, (%0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse8_v_u8mf4(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse8.v v1, (%0)"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle8_v_i8mf4(const void* ptr, size_t vlen) {
    asm volatile(
        "vle8.v v1, (%0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse8_v_i8mf4(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse8.v v1, (%0)"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle16_v_u16mf4(const void* ptr, size_t vlen) {
    asm volatile(
        "vle16.v v1, (%0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse16_v_u16mf4(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse16.v v1, (%0)"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle16_v_i16mf4(const void* ptr, size_t vlen) {
    asm volatile(
        "vle16.v v1, (%0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse16_v_i16mf4(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse16.v v1, (%0)"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle8_v_u8mf2(const void* ptr, size_t vlen) {
    asm volatile(
        "vle8.v v1, (%0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse8_v_u8mf2(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse8.v v1, (%0)"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle8_v_i8mf2(const void* ptr, size_t vlen) {
    asm volatile(
        "vle8.v v1, (%0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse8_v_i8mf2(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse8.v v1, (%0)"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle16_v_u16mf2(const void* ptr, size_t vlen) {
    asm volatile(
        "vle16.v v1, (%0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse16_v_u16mf2(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse16.v v1, (%0)"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle16_v_i16mf2(const void* ptr, size_t vlen) {
    asm volatile(
        "vle16.v v1, (%0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse16_v_i16mf2(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse16.v v1, (%0)"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle32_v_u32mf2(const void* ptr, size_t vlen) {
    asm volatile(
        "vle32.v v1, (%0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse32_v_u32mf2(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse32.v v1, (%0)"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle32_v_i32mf2(const void* ptr, size_t vlen) {
    asm volatile(
        "vle32.v v1, (%0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse32_v_i32mf2(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse32.v v1, (%0)"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle8_v_u8m1(const void* ptr, size_t vlen) {
    asm volatile(
        "vle8.v v1, (%0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse8_v_u8m1(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse8.v v1, (%0)"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle8_v_i8m1(const void* ptr, size_t vlen) {
    asm volatile(
        "vle8.v v1, (%0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse8_v_i8m1(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse8.v v1, (%0)"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle16_v_u16m1(const void* ptr, size_t vlen) {
    asm volatile(
        "vle16.v v1, (%0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse16_v_u16m1(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse16.v v1, (%0)"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle16_v_i16m1(const void* ptr, size_t vlen) {
    asm volatile(
        "vle16.v v1, (%0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse16_v_i16m1(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse16.v v1, (%0)"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle32_v_u32m1(const void* ptr, size_t vlen) {
    asm volatile(
        "vle32.v v1, (%0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse32_v_u32m1(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse32.v v1, (%0)"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle32_v_i32m1(const void* ptr, size_t vlen) {
    asm volatile(
        "vle32.v v1, (%0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse32_v_i32m1(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse32.v v1, (%0)"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle8_v_u8m2(const void* ptr, size_t vlen) {
    asm volatile(
        "vle8.v v2, (%0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse8_v_u8m2(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse8.v v2, (%0)"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle8_v_i8m2(const void* ptr, size_t vlen) {
    asm volatile(
        "vle8.v v2, (%0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse8_v_i8m2(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse8.v v2, (%0)"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle16_v_u16m2(const void* ptr, size_t vlen) {
    asm volatile(
        "vle16.v v2, (%0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse16_v_u16m2(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse16.v v2, (%0)"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle16_v_i16m2(const void* ptr, size_t vlen) {
    asm volatile(
        "vle16.v v2, (%0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse16_v_i16m2(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse16.v v2, (%0)"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle32_v_u32m2(const void* ptr, size_t vlen) {
    asm volatile(
        "vle32.v v2, (%0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse32_v_u32m2(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse32.v v2, (%0)"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle32_v_i32m2(const void* ptr, size_t vlen) {
    asm volatile(
        "vle32.v v2, (%0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse32_v_i32m2(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse32.v v2, (%0)"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle8_v_u8m4(const void* ptr, size_t vlen) {
    asm volatile(
        "vle8.v v4, (%0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse8_v_u8m4(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse8.v v4, (%0)"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle8_v_i8m4(const void* ptr, size_t vlen) {
    asm volatile(
        "vle8.v v4, (%0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse8_v_i8m4(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse8.v v4, (%0)"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle16_v_u16m4(const void* ptr, size_t vlen) {
    asm volatile(
        "vle16.v v4, (%0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse16_v_u16m4(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse16.v v4, (%0)"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle16_v_i16m4(const void* ptr, size_t vlen) {
    asm volatile(
        "vle16.v v4, (%0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse16_v_i16m4(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse16.v v4, (%0)"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle32_v_u32m4(const void* ptr, size_t vlen) {
    asm volatile(
        "vle32.v v4, (%0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse32_v_u32m4(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse32.v v4, (%0)"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle32_v_i32m4(const void* ptr, size_t vlen) {
    asm volatile(
        "vle32.v v4, (%0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse32_v_i32m4(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse32.v v4, (%0)"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle8_v_u8m8(const void* ptr, size_t vlen) {
    asm volatile(
        "vle8.v v8, (%0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse8_v_u8m8(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse8.v v8, (%0)"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle8_v_i8m8(const void* ptr, size_t vlen) {
    asm volatile(
        "vle8.v v8, (%0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse8_v_i8m8(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse8.v v8, (%0)"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle16_v_u16m8(const void* ptr, size_t vlen) {
    asm volatile(
        "vle16.v v8, (%0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse16_v_u16m8(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse16.v v8, (%0)"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle16_v_i16m8(const void* ptr, size_t vlen) {
    asm volatile(
        "vle16.v v8, (%0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse16_v_i16m8(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse16.v v8, (%0)"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle32_v_u32m8(const void* ptr, size_t vlen) {
    asm volatile(
        "vle32.v v8, (%0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse32_v_u32m8(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse32.v v8, (%0)"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vle32_v_i32m8(const void* ptr, size_t vlen) {
    asm volatile(
        "vle32.v v8, (%0)"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr) // use (ptr) to establish a dependency, but don't use it in the template
    );
    return 0;
}

void cheri_vse32_v_i32m8(void* ptr, int fake_data, size_t vlen) {
    asm volatile(
        "vse32.v v8, (%0)"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vlse8_v_u8mf8(const void* ptr, ptrdiff_t stride, size_t vlen) {
    asm volatile(
        "vlse8.v v1, (%0), %1"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr), "r"(stride)
    );
    return 0;
}

void cheri_vsse8_v_u8mf8(void* ptr, ptrdiff_t stride, int fake_data, size_t vlen) {
    asm volatile(
        "vsse8.v v1, (%0), %1"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr), "r"(stride) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vlse8_v_i8mf8(const void* ptr, ptrdiff_t stride, size_t vlen) {
    asm volatile(
        "vlse8.v v1, (%0), %1"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr), "r"(stride)
    );
    return 0;
}

void cheri_vsse8_v_i8mf8(void* ptr, ptrdiff_t stride, int fake_data, size_t vlen) {
    asm volatile(
        "vsse8.v v1, (%0), %1"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr), "r"(stride) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vlse8_v_u8mf4(const void* ptr, ptrdiff_t stride, size_t vlen) {
    asm volatile(
        "vlse8.v v1, (%0), %1"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr), "r"(stride)
    );
    return 0;
}

void cheri_vsse8_v_u8mf4(void* ptr, ptrdiff_t stride, int fake_data, size_t vlen) {
    asm volatile(
        "vsse8.v v1, (%0), %1"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr), "r"(stride) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vlse8_v_i8mf4(const void* ptr, ptrdiff_t stride, size_t vlen) {
    asm volatile(
        "vlse8.v v1, (%0), %1"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr), "r"(stride)
    );
    return 0;
}

void cheri_vsse8_v_i8mf4(void* ptr, ptrdiff_t stride, int fake_data, size_t vlen) {
    asm volatile(
        "vsse8.v v1, (%0), %1"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr), "r"(stride) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vlse16_v_u16mf4(const void* ptr, ptrdiff_t stride, size_t vlen) {
    asm volatile(
        "vlse16.v v1, (%0), %1"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr), "r"(stride)
    );
    return 0;
}

void cheri_vsse16_v_u16mf4(void* ptr, ptrdiff_t stride, int fake_data, size_t vlen) {
    asm volatile(
        "vsse16.v v1, (%0), %1"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr), "r"(stride) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vlse16_v_i16mf4(const void* ptr, ptrdiff_t stride, size_t vlen) {
    asm volatile(
        "vlse16.v v1, (%0), %1"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr), "r"(stride)
    );
    return 0;
}

void cheri_vsse16_v_i16mf4(void* ptr, ptrdiff_t stride, int fake_data, size_t vlen) {
    asm volatile(
        "vsse16.v v1, (%0), %1"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr), "r"(stride) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vlse8_v_u8mf2(const void* ptr, ptrdiff_t stride, size_t vlen) {
    asm volatile(
        "vlse8.v v1, (%0), %1"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr), "r"(stride)
    );
    return 0;
}

void cheri_vsse8_v_u8mf2(void* ptr, ptrdiff_t stride, int fake_data, size_t vlen) {
    asm volatile(
        "vsse8.v v1, (%0), %1"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr), "r"(stride) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vlse8_v_i8mf2(const void* ptr, ptrdiff_t stride, size_t vlen) {
    asm volatile(
        "vlse8.v v1, (%0), %1"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr), "r"(stride)
    );
    return 0;
}

void cheri_vsse8_v_i8mf2(void* ptr, ptrdiff_t stride, int fake_data, size_t vlen) {
    asm volatile(
        "vsse8.v v1, (%0), %1"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr), "r"(stride) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vlse16_v_u16mf2(const void* ptr, ptrdiff_t stride, size_t vlen) {
    asm volatile(
        "vlse16.v v1, (%0), %1"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr), "r"(stride)
    );
    return 0;
}

void cheri_vsse16_v_u16mf2(void* ptr, ptrdiff_t stride, int fake_data, size_t vlen) {
    asm volatile(
        "vsse16.v v1, (%0), %1"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr), "r"(stride) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vlse16_v_i16mf2(const void* ptr, ptrdiff_t stride, size_t vlen) {
    asm volatile(
        "vlse16.v v1, (%0), %1"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr), "r"(stride)
    );
    return 0;
}

void cheri_vsse16_v_i16mf2(void* ptr, ptrdiff_t stride, int fake_data, size_t vlen) {
    asm volatile(
        "vsse16.v v1, (%0), %1"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr), "r"(stride) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vlse32_v_u32mf2(const void* ptr, ptrdiff_t stride, size_t vlen) {
    asm volatile(
        "vlse32.v v1, (%0), %1"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr), "r"(stride)
    );
    return 0;
}

void cheri_vsse32_v_u32mf2(void* ptr, ptrdiff_t stride, int fake_data, size_t vlen) {
    asm volatile(
        "vsse32.v v1, (%0), %1"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr), "r"(stride) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vlse32_v_i32mf2(const void* ptr, ptrdiff_t stride, size_t vlen) {
    asm volatile(
        "vlse32.v v1, (%0), %1"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr), "r"(stride)
    );
    return 0;
}

void cheri_vsse32_v_i32mf2(void* ptr, ptrdiff_t stride, int fake_data, size_t vlen) {
    asm volatile(
        "vsse32.v v1, (%0), %1"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr), "r"(stride) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vlse8_v_u8m1(const void* ptr, ptrdiff_t stride, size_t vlen) {
    asm volatile(
        "vlse8.v v1, (%0), %1"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr), "r"(stride)
    );
    return 0;
}

void cheri_vsse8_v_u8m1(void* ptr, ptrdiff_t stride, int fake_data, size_t vlen) {
    asm volatile(
        "vsse8.v v1, (%0), %1"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr), "r"(stride) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vlse8_v_i8m1(const void* ptr, ptrdiff_t stride, size_t vlen) {
    asm volatile(
        "vlse8.v v1, (%0), %1"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr), "r"(stride)
    );
    return 0;
}

void cheri_vsse8_v_i8m1(void* ptr, ptrdiff_t stride, int fake_data, size_t vlen) {
    asm volatile(
        "vsse8.v v1, (%0), %1"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr), "r"(stride) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vlse16_v_u16m1(const void* ptr, ptrdiff_t stride, size_t vlen) {
    asm volatile(
        "vlse16.v v1, (%0), %1"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr), "r"(stride)
    );
    return 0;
}

void cheri_vsse16_v_u16m1(void* ptr, ptrdiff_t stride, int fake_data, size_t vlen) {
    asm volatile(
        "vsse16.v v1, (%0), %1"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr), "r"(stride) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vlse16_v_i16m1(const void* ptr, ptrdiff_t stride, size_t vlen) {
    asm volatile(
        "vlse16.v v1, (%0), %1"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr), "r"(stride)
    );
    return 0;
}

void cheri_vsse16_v_i16m1(void* ptr, ptrdiff_t stride, int fake_data, size_t vlen) {
    asm volatile(
        "vsse16.v v1, (%0), %1"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr), "r"(stride) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vlse32_v_u32m1(const void* ptr, ptrdiff_t stride, size_t vlen) {
    asm volatile(
        "vlse32.v v1, (%0), %1"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr), "r"(stride)
    );
    return 0;
}

void cheri_vsse32_v_u32m1(void* ptr, ptrdiff_t stride, int fake_data, size_t vlen) {
    asm volatile(
        "vsse32.v v1, (%0), %1"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr), "r"(stride) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vlse32_v_i32m1(const void* ptr, ptrdiff_t stride, size_t vlen) {
    asm volatile(
        "vlse32.v v1, (%0), %1"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr), "r"(stride)
    );
    return 0;
}

void cheri_vsse32_v_i32m1(void* ptr, ptrdiff_t stride, int fake_data, size_t vlen) {
    asm volatile(
        "vsse32.v v1, (%0), %1"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr), "r"(stride) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vlse8_v_u8m2(const void* ptr, ptrdiff_t stride, size_t vlen) {
    asm volatile(
        "vlse8.v v2, (%0), %1"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr), "r"(stride)
    );
    return 0;
}

void cheri_vsse8_v_u8m2(void* ptr, ptrdiff_t stride, int fake_data, size_t vlen) {
    asm volatile(
        "vsse8.v v2, (%0), %1"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr), "r"(stride) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vlse8_v_i8m2(const void* ptr, ptrdiff_t stride, size_t vlen) {
    asm volatile(
        "vlse8.v v2, (%0), %1"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr), "r"(stride)
    );
    return 0;
}

void cheri_vsse8_v_i8m2(void* ptr, ptrdiff_t stride, int fake_data, size_t vlen) {
    asm volatile(
        "vsse8.v v2, (%0), %1"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr), "r"(stride) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vlse16_v_u16m2(const void* ptr, ptrdiff_t stride, size_t vlen) {
    asm volatile(
        "vlse16.v v2, (%0), %1"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr), "r"(stride)
    );
    return 0;
}

void cheri_vsse16_v_u16m2(void* ptr, ptrdiff_t stride, int fake_data, size_t vlen) {
    asm volatile(
        "vsse16.v v2, (%0), %1"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr), "r"(stride) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vlse16_v_i16m2(const void* ptr, ptrdiff_t stride, size_t vlen) {
    asm volatile(
        "vlse16.v v2, (%0), %1"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr), "r"(stride)
    );
    return 0;
}

void cheri_vsse16_v_i16m2(void* ptr, ptrdiff_t stride, int fake_data, size_t vlen) {
    asm volatile(
        "vsse16.v v2, (%0), %1"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr), "r"(stride) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vlse32_v_u32m2(const void* ptr, ptrdiff_t stride, size_t vlen) {
    asm volatile(
        "vlse32.v v2, (%0), %1"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr), "r"(stride)
    );
    return 0;
}

void cheri_vsse32_v_u32m2(void* ptr, ptrdiff_t stride, int fake_data, size_t vlen) {
    asm volatile(
        "vsse32.v v2, (%0), %1"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr), "r"(stride) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vlse32_v_i32m2(const void* ptr, ptrdiff_t stride, size_t vlen) {
    asm volatile(
        "vlse32.v v2, (%0), %1"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr), "r"(stride)
    );
    return 0;
}

void cheri_vsse32_v_i32m2(void* ptr, ptrdiff_t stride, int fake_data, size_t vlen) {
    asm volatile(
        "vsse32.v v2, (%0), %1"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr), "r"(stride) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vlse8_v_u8m4(const void* ptr, ptrdiff_t stride, size_t vlen) {
    asm volatile(
        "vlse8.v v4, (%0), %1"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr), "r"(stride)
    );
    return 0;
}

void cheri_vsse8_v_u8m4(void* ptr, ptrdiff_t stride, int fake_data, size_t vlen) {
    asm volatile(
        "vsse8.v v4, (%0), %1"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr), "r"(stride) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vlse8_v_i8m4(const void* ptr, ptrdiff_t stride, size_t vlen) {
    asm volatile(
        "vlse8.v v4, (%0), %1"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr), "r"(stride)
    );
    return 0;
}

void cheri_vsse8_v_i8m4(void* ptr, ptrdiff_t stride, int fake_data, size_t vlen) {
    asm volatile(
        "vsse8.v v4, (%0), %1"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr), "r"(stride) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vlse16_v_u16m4(const void* ptr, ptrdiff_t stride, size_t vlen) {
    asm volatile(
        "vlse16.v v4, (%0), %1"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr), "r"(stride)
    );
    return 0;
}

void cheri_vsse16_v_u16m4(void* ptr, ptrdiff_t stride, int fake_data, size_t vlen) {
    asm volatile(
        "vsse16.v v4, (%0), %1"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr), "r"(stride) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vlse16_v_i16m4(const void* ptr, ptrdiff_t stride, size_t vlen) {
    asm volatile(
        "vlse16.v v4, (%0), %1"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr), "r"(stride)
    );
    return 0;
}

void cheri_vsse16_v_i16m4(void* ptr, ptrdiff_t stride, int fake_data, size_t vlen) {
    asm volatile(
        "vsse16.v v4, (%0), %1"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr), "r"(stride) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vlse32_v_u32m4(const void* ptr, ptrdiff_t stride, size_t vlen) {
    asm volatile(
        "vlse32.v v4, (%0), %1"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr), "r"(stride)
    );
    return 0;
}

void cheri_vsse32_v_u32m4(void* ptr, ptrdiff_t stride, int fake_data, size_t vlen) {
    asm volatile(
        "vsse32.v v4, (%0), %1"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr), "r"(stride) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vlse32_v_i32m4(const void* ptr, ptrdiff_t stride, size_t vlen) {
    asm volatile(
        "vlse32.v v4, (%0), %1"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr), "r"(stride)
    );
    return 0;
}

void cheri_vsse32_v_i32m4(void* ptr, ptrdiff_t stride, int fake_data, size_t vlen) {
    asm volatile(
        "vsse32.v v4, (%0), %1"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr), "r"(stride) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vlse8_v_u8m8(const void* ptr, ptrdiff_t stride, size_t vlen) {
    asm volatile(
        "vlse8.v v8, (%0), %1"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr), "r"(stride)
    );
    return 0;
}

void cheri_vsse8_v_u8m8(void* ptr, ptrdiff_t stride, int fake_data, size_t vlen) {
    asm volatile(
        "vsse8.v v8, (%0), %1"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr), "r"(stride) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vlse8_v_i8m8(const void* ptr, ptrdiff_t stride, size_t vlen) {
    asm volatile(
        "vlse8.v v8, (%0), %1"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr), "r"(stride)
    );
    return 0;
}

void cheri_vsse8_v_i8m8(void* ptr, ptrdiff_t stride, int fake_data, size_t vlen) {
    asm volatile(
        "vsse8.v v8, (%0), %1"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr), "r"(stride) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vlse16_v_u16m8(const void* ptr, ptrdiff_t stride, size_t vlen) {
    asm volatile(
        "vlse16.v v8, (%0), %1"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr), "r"(stride)
    );
    return 0;
}

void cheri_vsse16_v_u16m8(void* ptr, ptrdiff_t stride, int fake_data, size_t vlen) {
    asm volatile(
        "vsse16.v v8, (%0), %1"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr), "r"(stride) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vlse16_v_i16m8(const void* ptr, ptrdiff_t stride, size_t vlen) {
    asm volatile(
        "vlse16.v v8, (%0), %1"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr), "r"(stride)
    );
    return 0;
}

void cheri_vsse16_v_i16m8(void* ptr, ptrdiff_t stride, int fake_data, size_t vlen) {
    asm volatile(
        "vsse16.v v8, (%0), %1"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr), "r"(stride) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vlse32_v_u32m8(const void* ptr, ptrdiff_t stride, size_t vlen) {
    asm volatile(
        "vlse32.v v8, (%0), %1"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr), "r"(stride)
    );
    return 0;
}

void cheri_vsse32_v_u32m8(void* ptr, ptrdiff_t stride, int fake_data, size_t vlen) {
    asm volatile(
        "vsse32.v v8, (%0), %1"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr), "r"(stride) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}

int cheri_vlse32_v_i32m8(const void* ptr, ptrdiff_t stride, size_t vlen) {
    asm volatile(
        "vlse32.v v8, (%0), %1"
        : // we specify output register directly - passing vectors thru the stack doesn't work with CHERI
        : "C"(ptr), "r"(stride)
    );
    return 0;
}

void cheri_vsse32_v_i32m8(void* ptr, ptrdiff_t stride, int fake_data, size_t vlen) {
    asm volatile(
        "vsse32.v v8, (%0), %1"
        : // no "outputs" (we write out to *ptr but can't do "=m"(*ptr))
        : "C"(ptr), "r"(stride) // input vector register specified directly - passing vectors thru the stack doesn't work with CHERI
        : "memory"
    );
}
#endif // __has_feature(capabilities)
#endif // CHERI_VECTOR_WRAPPERS