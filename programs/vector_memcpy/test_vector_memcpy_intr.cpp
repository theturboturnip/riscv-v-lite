
#include <stdint.h>
#include <riscv_vector.h>

// This file is autogenerated by vector_intrinsic_gen.py
// It provides equivalents to RISC-V vector load/store instrinsics that are CHERI-compatible.
// Function names are prefixed with 'cheri_'

// The reason this is needed at all is because the vector intrinsics haven't been adjusted for CHERI support.
// This can be fixed by using inline assembly, but there's a catch.
// Inline assembly in CHERI-Clang (and also normal Clang trunk) will by default insert offsets in front of memory addresses
// e.g. 'vse8.v v8, 0(ca0)'
// RISC-V Vectors don't support offsets on loads/stores, and reject this.
// To get around this, we wrap each inline asm in a function, 
// and hardcode the address as '(ca0)' with no offset.
// This works because the first argument to each function is the pointer,
// and the RISC-V CHERI ABI puts that argument in the ca0 register every time.

vuint8mf8_t cheri_vle8_v_u8mf8(const uint8_t* ptr, size_t vlen) {
    vuint8mf8_t data;
    asm volatile(
        "vle8.v %0, (ca0)"
        : "=vr"(data) // Vector register output
        : // no extra input (we specify ca0 directly)
    )
    return data;
}

void cheri_vse8_v_u8mf8(uint8_t* ptr, vuint8mf8_t data, size_t vlen) {
    asm volatile(
        "vse8.v %0, (ca0)"
        : // no output (we specify ca0 directly)
        : "vr"(data) // input = vector register
        : "memory"
    )
}

vuint16mf8_t cheri_vle16_v_u16mf8(const uint8_t* ptr, size_t vlen) {
    vuint16mf8_t data;
    asm volatile(
        "vle16.v %0, (ca0)"
        : "=vr"(data) // Vector register output
        : // no extra input (we specify ca0 directly)
    )
    return data;
}

void cheri_vse16_v_u16mf8(uint8_t* ptr, vuint16mf8_t data, size_t vlen) {
    asm volatile(
        "vse16.v %0, (ca0)"
        : // no output (we specify ca0 directly)
        : "vr"(data) // input = vector register
        : "memory"
    )
}

vuint32mf8_t cheri_vle32_v_u32mf8(const uint8_t* ptr, size_t vlen) {
    vuint32mf8_t data;
    asm volatile(
        "vle32.v %0, (ca0)"
        : "=vr"(data) // Vector register output
        : // no extra input (we specify ca0 directly)
    )
    return data;
}

void cheri_vse32_v_u32mf8(uint8_t* ptr, vuint32mf8_t data, size_t vlen) {
    asm volatile(
        "vse32.v %0, (ca0)"
        : // no output (we specify ca0 directly)
        : "vr"(data) // input = vector register
        : "memory"
    )
}

vuint8mf4_t cheri_vle8_v_u8mf4(const uint8_t* ptr, size_t vlen) {
    vuint8mf4_t data;
    asm volatile(
        "vle8.v %0, (ca0)"
        : "=vr"(data) // Vector register output
        : // no extra input (we specify ca0 directly)
    )
    return data;
}

void cheri_vse8_v_u8mf4(uint8_t* ptr, vuint8mf4_t data, size_t vlen) {
    asm volatile(
        "vse8.v %0, (ca0)"
        : // no output (we specify ca0 directly)
        : "vr"(data) // input = vector register
        : "memory"
    )
}

vuint16mf4_t cheri_vle16_v_u16mf4(const uint8_t* ptr, size_t vlen) {
    vuint16mf4_t data;
    asm volatile(
        "vle16.v %0, (ca0)"
        : "=vr"(data) // Vector register output
        : // no extra input (we specify ca0 directly)
    )
    return data;
}

void cheri_vse16_v_u16mf4(uint8_t* ptr, vuint16mf4_t data, size_t vlen) {
    asm volatile(
        "vse16.v %0, (ca0)"
        : // no output (we specify ca0 directly)
        : "vr"(data) // input = vector register
        : "memory"
    )
}

vuint32mf4_t cheri_vle32_v_u32mf4(const uint8_t* ptr, size_t vlen) {
    vuint32mf4_t data;
    asm volatile(
        "vle32.v %0, (ca0)"
        : "=vr"(data) // Vector register output
        : // no extra input (we specify ca0 directly)
    )
    return data;
}

void cheri_vse32_v_u32mf4(uint8_t* ptr, vuint32mf4_t data, size_t vlen) {
    asm volatile(
        "vse32.v %0, (ca0)"
        : // no output (we specify ca0 directly)
        : "vr"(data) // input = vector register
        : "memory"
    )
}

vuint8mf2_t cheri_vle8_v_u8mf2(const uint8_t* ptr, size_t vlen) {
    vuint8mf2_t data;
    asm volatile(
        "vle8.v %0, (ca0)"
        : "=vr"(data) // Vector register output
        : // no extra input (we specify ca0 directly)
    )
    return data;
}

void cheri_vse8_v_u8mf2(uint8_t* ptr, vuint8mf2_t data, size_t vlen) {
    asm volatile(
        "vse8.v %0, (ca0)"
        : // no output (we specify ca0 directly)
        : "vr"(data) // input = vector register
        : "memory"
    )
}

vuint16mf2_t cheri_vle16_v_u16mf2(const uint8_t* ptr, size_t vlen) {
    vuint16mf2_t data;
    asm volatile(
        "vle16.v %0, (ca0)"
        : "=vr"(data) // Vector register output
        : // no extra input (we specify ca0 directly)
    )
    return data;
}

void cheri_vse16_v_u16mf2(uint8_t* ptr, vuint16mf2_t data, size_t vlen) {
    asm volatile(
        "vse16.v %0, (ca0)"
        : // no output (we specify ca0 directly)
        : "vr"(data) // input = vector register
        : "memory"
    )
}

vuint32mf2_t cheri_vle32_v_u32mf2(const uint8_t* ptr, size_t vlen) {
    vuint32mf2_t data;
    asm volatile(
        "vle32.v %0, (ca0)"
        : "=vr"(data) // Vector register output
        : // no extra input (we specify ca0 directly)
    )
    return data;
}

void cheri_vse32_v_u32mf2(uint8_t* ptr, vuint32mf2_t data, size_t vlen) {
    asm volatile(
        "vse32.v %0, (ca0)"
        : // no output (we specify ca0 directly)
        : "vr"(data) // input = vector register
        : "memory"
    )
}

vuint8m1_t cheri_vle8_v_u8m1(const uint8_t* ptr, size_t vlen) {
    vuint8m1_t data;
    asm volatile(
        "vle8.v %0, (ca0)"
        : "=vr"(data) // Vector register output
        : // no extra input (we specify ca0 directly)
    )
    return data;
}

void cheri_vse8_v_u8m1(uint8_t* ptr, vuint8m1_t data, size_t vlen) {
    asm volatile(
        "vse8.v %0, (ca0)"
        : // no output (we specify ca0 directly)
        : "vr"(data) // input = vector register
        : "memory"
    )
}

vuint16m1_t cheri_vle16_v_u16m1(const uint8_t* ptr, size_t vlen) {
    vuint16m1_t data;
    asm volatile(
        "vle16.v %0, (ca0)"
        : "=vr"(data) // Vector register output
        : // no extra input (we specify ca0 directly)
    )
    return data;
}

void cheri_vse16_v_u16m1(uint8_t* ptr, vuint16m1_t data, size_t vlen) {
    asm volatile(
        "vse16.v %0, (ca0)"
        : // no output (we specify ca0 directly)
        : "vr"(data) // input = vector register
        : "memory"
    )
}

vuint32m1_t cheri_vle32_v_u32m1(const uint8_t* ptr, size_t vlen) {
    vuint32m1_t data;
    asm volatile(
        "vle32.v %0, (ca0)"
        : "=vr"(data) // Vector register output
        : // no extra input (we specify ca0 directly)
    )
    return data;
}

void cheri_vse32_v_u32m1(uint8_t* ptr, vuint32m1_t data, size_t vlen) {
    asm volatile(
        "vse32.v %0, (ca0)"
        : // no output (we specify ca0 directly)
        : "vr"(data) // input = vector register
        : "memory"
    )
}

vuint8m2_t cheri_vle8_v_u8m2(const uint8_t* ptr, size_t vlen) {
    vuint8m2_t data;
    asm volatile(
        "vle8.v %0, (ca0)"
        : "=vr"(data) // Vector register output
        : // no extra input (we specify ca0 directly)
    )
    return data;
}

void cheri_vse8_v_u8m2(uint8_t* ptr, vuint8m2_t data, size_t vlen) {
    asm volatile(
        "vse8.v %0, (ca0)"
        : // no output (we specify ca0 directly)
        : "vr"(data) // input = vector register
        : "memory"
    )
}

vuint16m2_t cheri_vle16_v_u16m2(const uint8_t* ptr, size_t vlen) {
    vuint16m2_t data;
    asm volatile(
        "vle16.v %0, (ca0)"
        : "=vr"(data) // Vector register output
        : // no extra input (we specify ca0 directly)
    )
    return data;
}

void cheri_vse16_v_u16m2(uint8_t* ptr, vuint16m2_t data, size_t vlen) {
    asm volatile(
        "vse16.v %0, (ca0)"
        : // no output (we specify ca0 directly)
        : "vr"(data) // input = vector register
        : "memory"
    )
}

vuint32m2_t cheri_vle32_v_u32m2(const uint8_t* ptr, size_t vlen) {
    vuint32m2_t data;
    asm volatile(
        "vle32.v %0, (ca0)"
        : "=vr"(data) // Vector register output
        : // no extra input (we specify ca0 directly)
    )
    return data;
}

void cheri_vse32_v_u32m2(uint8_t* ptr, vuint32m2_t data, size_t vlen) {
    asm volatile(
        "vse32.v %0, (ca0)"
        : // no output (we specify ca0 directly)
        : "vr"(data) // input = vector register
        : "memory"
    )
}

vuint8m4_t cheri_vle8_v_u8m4(const uint8_t* ptr, size_t vlen) {
    vuint8m4_t data;
    asm volatile(
        "vle8.v %0, (ca0)"
        : "=vr"(data) // Vector register output
        : // no extra input (we specify ca0 directly)
    )
    return data;
}

void cheri_vse8_v_u8m4(uint8_t* ptr, vuint8m4_t data, size_t vlen) {
    asm volatile(
        "vse8.v %0, (ca0)"
        : // no output (we specify ca0 directly)
        : "vr"(data) // input = vector register
        : "memory"
    )
}

vuint16m4_t cheri_vle16_v_u16m4(const uint8_t* ptr, size_t vlen) {
    vuint16m4_t data;
    asm volatile(
        "vle16.v %0, (ca0)"
        : "=vr"(data) // Vector register output
        : // no extra input (we specify ca0 directly)
    )
    return data;
}

void cheri_vse16_v_u16m4(uint8_t* ptr, vuint16m4_t data, size_t vlen) {
    asm volatile(
        "vse16.v %0, (ca0)"
        : // no output (we specify ca0 directly)
        : "vr"(data) // input = vector register
        : "memory"
    )
}

vuint32m4_t cheri_vle32_v_u32m4(const uint8_t* ptr, size_t vlen) {
    vuint32m4_t data;
    asm volatile(
        "vle32.v %0, (ca0)"
        : "=vr"(data) // Vector register output
        : // no extra input (we specify ca0 directly)
    )
    return data;
}

void cheri_vse32_v_u32m4(uint8_t* ptr, vuint32m4_t data, size_t vlen) {
    asm volatile(
        "vse32.v %0, (ca0)"
        : // no output (we specify ca0 directly)
        : "vr"(data) // input = vector register
        : "memory"
    )
}

vuint8m8_t cheri_vle8_v_u8m8(const uint8_t* ptr, size_t vlen) {
    vuint8m8_t data;
    asm volatile(
        "vle8.v %0, (ca0)"
        : "=vr"(data) // Vector register output
        : // no extra input (we specify ca0 directly)
    )
    return data;
}

void cheri_vse8_v_u8m8(uint8_t* ptr, vuint8m8_t data, size_t vlen) {
    asm volatile(
        "vse8.v %0, (ca0)"
        : // no output (we specify ca0 directly)
        : "vr"(data) // input = vector register
        : "memory"
    )
}

vuint16m8_t cheri_vle16_v_u16m8(const uint8_t* ptr, size_t vlen) {
    vuint16m8_t data;
    asm volatile(
        "vle16.v %0, (ca0)"
        : "=vr"(data) // Vector register output
        : // no extra input (we specify ca0 directly)
    )
    return data;
}

void cheri_vse16_v_u16m8(uint8_t* ptr, vuint16m8_t data, size_t vlen) {
    asm volatile(
        "vse16.v %0, (ca0)"
        : // no output (we specify ca0 directly)
        : "vr"(data) // input = vector register
        : "memory"
    )
}

vuint32m8_t cheri_vle32_v_u32m8(const uint8_t* ptr, size_t vlen) {
    vuint32m8_t data;
    asm volatile(
        "vle32.v %0, (ca0)"
        : "=vr"(data) // Vector register output
        : // no extra input (we specify ca0 directly)
    )
    return data;
}

void cheri_vse32_v_u32m8(uint8_t* ptr, vuint32m8_t data, size_t vlen) {
    asm volatile(
        "vse32.v %0, (ca0)"
        : // no output (we specify ca0 directly)
        : "vr"(data) // input = vector register
        : "memory"
    )
}
