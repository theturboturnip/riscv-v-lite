#ifndef CHERI_VECTOR_WRAPPERS
#define CHERI_VECTOR_WRAPPERS
#include <stdint.h>
#include <riscv_vector.h>

// This file is autogenerated by vector_intrinsic_gen.py
// It provides equivalents to RISC-V vector load/store instrinsics that are CHERI-compatible.
// Function names are prefixed with 'cheri_'

// The reason this is needed at all is because the vector intrinsics haven't been adjusted for CHERI support.
// This can be fixed by using inline assembly, but there's a catch.
// Inline assembly in CHERI-Clang (and also normal Clang trunk) will by default insert offsets in front of memory addresses
// e.g. 'vse8.v v8, 0(ca0)'
// RISC-V Vectors don't support offsets on loads/stores, and reject this.
// To get around this, we wrap each inline asm in a function, 
// and hardcode the address as '(ca0)' with no offset.
// This works because the first argument to each function is the pointer,
// and the RISC-V CHERI ABI puts that argument in the ca0 register every time.

// Define VEC_INTRIN(i) which calls the CHERI version if available
#if __has_feature(capabilities)
#define VEC_INTRIN(i) cheri_ ## i
#else
#define VEC_INTRIN(i) i
#endif // __has_feature(capabilities)

// Only generate CHERI versions if we're in CHERI
#if __has_feature(capabilities)

vuint8mf8_t cheri_vle8_v_u8mf8(const void* ptr, size_t vlen) {
    vuint8mf8_t data;
    asm volatile(
        "vle8.v %0, (ca0)"
        : "=vr"(data) // Vector register output
        : // no extra input (we specify ca0 directly)
    );
    return data;
}

void cheri_vse8_v_u8mf8(void* ptr, vuint8mf8_t data, size_t vlen) {
    asm volatile(
        "vse8.v %0, (ca0)"
        : // no output (we specify ca0 directly)
        : "vr"(data) // input = vector register
        : "memory"
    );
}

vint8mf8_t cheri_vle8_v_i8mf8(const void* ptr, size_t vlen) {
    vint8mf8_t data;
    asm volatile(
        "vle8.v %0, (ca0)"
        : "=vr"(data) // Vector register output
        : // no extra input (we specify ca0 directly)
    );
    return data;
}

void cheri_vse8_v_i8mf8(void* ptr, vint8mf8_t data, size_t vlen) {
    asm volatile(
        "vse8.v %0, (ca0)"
        : // no output (we specify ca0 directly)
        : "vr"(data) // input = vector register
        : "memory"
    );
}

vuint8mf4_t cheri_vle8_v_u8mf4(const void* ptr, size_t vlen) {
    vuint8mf4_t data;
    asm volatile(
        "vle8.v %0, (ca0)"
        : "=vr"(data) // Vector register output
        : // no extra input (we specify ca0 directly)
    );
    return data;
}

void cheri_vse8_v_u8mf4(void* ptr, vuint8mf4_t data, size_t vlen) {
    asm volatile(
        "vse8.v %0, (ca0)"
        : // no output (we specify ca0 directly)
        : "vr"(data) // input = vector register
        : "memory"
    );
}

vint8mf4_t cheri_vle8_v_i8mf4(const void* ptr, size_t vlen) {
    vint8mf4_t data;
    asm volatile(
        "vle8.v %0, (ca0)"
        : "=vr"(data) // Vector register output
        : // no extra input (we specify ca0 directly)
    );
    return data;
}

void cheri_vse8_v_i8mf4(void* ptr, vint8mf4_t data, size_t vlen) {
    asm volatile(
        "vse8.v %0, (ca0)"
        : // no output (we specify ca0 directly)
        : "vr"(data) // input = vector register
        : "memory"
    );
}

vuint16mf4_t cheri_vle16_v_u16mf4(const void* ptr, size_t vlen) {
    vuint16mf4_t data;
    asm volatile(
        "vle16.v %0, (ca0)"
        : "=vr"(data) // Vector register output
        : // no extra input (we specify ca0 directly)
    );
    return data;
}

void cheri_vse16_v_u16mf4(void* ptr, vuint16mf4_t data, size_t vlen) {
    asm volatile(
        "vse16.v %0, (ca0)"
        : // no output (we specify ca0 directly)
        : "vr"(data) // input = vector register
        : "memory"
    );
}

vint16mf4_t cheri_vle16_v_i16mf4(const void* ptr, size_t vlen) {
    vint16mf4_t data;
    asm volatile(
        "vle16.v %0, (ca0)"
        : "=vr"(data) // Vector register output
        : // no extra input (we specify ca0 directly)
    );
    return data;
}

void cheri_vse16_v_i16mf4(void* ptr, vint16mf4_t data, size_t vlen) {
    asm volatile(
        "vse16.v %0, (ca0)"
        : // no output (we specify ca0 directly)
        : "vr"(data) // input = vector register
        : "memory"
    );
}

vuint8mf2_t cheri_vle8_v_u8mf2(const void* ptr, size_t vlen) {
    vuint8mf2_t data;
    asm volatile(
        "vle8.v %0, (ca0)"
        : "=vr"(data) // Vector register output
        : // no extra input (we specify ca0 directly)
    );
    return data;
}

void cheri_vse8_v_u8mf2(void* ptr, vuint8mf2_t data, size_t vlen) {
    asm volatile(
        "vse8.v %0, (ca0)"
        : // no output (we specify ca0 directly)
        : "vr"(data) // input = vector register
        : "memory"
    );
}

vint8mf2_t cheri_vle8_v_i8mf2(const void* ptr, size_t vlen) {
    vint8mf2_t data;
    asm volatile(
        "vle8.v %0, (ca0)"
        : "=vr"(data) // Vector register output
        : // no extra input (we specify ca0 directly)
    );
    return data;
}

void cheri_vse8_v_i8mf2(void* ptr, vint8mf2_t data, size_t vlen) {
    asm volatile(
        "vse8.v %0, (ca0)"
        : // no output (we specify ca0 directly)
        : "vr"(data) // input = vector register
        : "memory"
    );
}

vuint16mf2_t cheri_vle16_v_u16mf2(const void* ptr, size_t vlen) {
    vuint16mf2_t data;
    asm volatile(
        "vle16.v %0, (ca0)"
        : "=vr"(data) // Vector register output
        : // no extra input (we specify ca0 directly)
    );
    return data;
}

void cheri_vse16_v_u16mf2(void* ptr, vuint16mf2_t data, size_t vlen) {
    asm volatile(
        "vse16.v %0, (ca0)"
        : // no output (we specify ca0 directly)
        : "vr"(data) // input = vector register
        : "memory"
    );
}

vint16mf2_t cheri_vle16_v_i16mf2(const void* ptr, size_t vlen) {
    vint16mf2_t data;
    asm volatile(
        "vle16.v %0, (ca0)"
        : "=vr"(data) // Vector register output
        : // no extra input (we specify ca0 directly)
    );
    return data;
}

void cheri_vse16_v_i16mf2(void* ptr, vint16mf2_t data, size_t vlen) {
    asm volatile(
        "vse16.v %0, (ca0)"
        : // no output (we specify ca0 directly)
        : "vr"(data) // input = vector register
        : "memory"
    );
}

vuint32mf2_t cheri_vle32_v_u32mf2(const void* ptr, size_t vlen) {
    vuint32mf2_t data;
    asm volatile(
        "vle32.v %0, (ca0)"
        : "=vr"(data) // Vector register output
        : // no extra input (we specify ca0 directly)
    );
    return data;
}

void cheri_vse32_v_u32mf2(void* ptr, vuint32mf2_t data, size_t vlen) {
    asm volatile(
        "vse32.v %0, (ca0)"
        : // no output (we specify ca0 directly)
        : "vr"(data) // input = vector register
        : "memory"
    );
}

vint32mf2_t cheri_vle32_v_i32mf2(const void* ptr, size_t vlen) {
    vint32mf2_t data;
    asm volatile(
        "vle32.v %0, (ca0)"
        : "=vr"(data) // Vector register output
        : // no extra input (we specify ca0 directly)
    );
    return data;
}

void cheri_vse32_v_i32mf2(void* ptr, vint32mf2_t data, size_t vlen) {
    asm volatile(
        "vse32.v %0, (ca0)"
        : // no output (we specify ca0 directly)
        : "vr"(data) // input = vector register
        : "memory"
    );
}

vuint8m1_t cheri_vle8_v_u8m1(const void* ptr, size_t vlen) {
    vuint8m1_t data;
    asm volatile(
        "vle8.v %0, (ca0)"
        : "=vr"(data) // Vector register output
        : // no extra input (we specify ca0 directly)
    );
    return data;
}

void cheri_vse8_v_u8m1(void* ptr, vuint8m1_t data, size_t vlen) {
    asm volatile(
        "vse8.v %0, (ca0)"
        : // no output (we specify ca0 directly)
        : "vr"(data) // input = vector register
        : "memory"
    );
}

vint8m1_t cheri_vle8_v_i8m1(const void* ptr, size_t vlen) {
    vint8m1_t data;
    asm volatile(
        "vle8.v %0, (ca0)"
        : "=vr"(data) // Vector register output
        : // no extra input (we specify ca0 directly)
    );
    return data;
}

void cheri_vse8_v_i8m1(void* ptr, vint8m1_t data, size_t vlen) {
    asm volatile(
        "vse8.v %0, (ca0)"
        : // no output (we specify ca0 directly)
        : "vr"(data) // input = vector register
        : "memory"
    );
}

vuint16m1_t cheri_vle16_v_u16m1(const void* ptr, size_t vlen) {
    vuint16m1_t data;
    asm volatile(
        "vle16.v %0, (ca0)"
        : "=vr"(data) // Vector register output
        : // no extra input (we specify ca0 directly)
    );
    return data;
}

void cheri_vse16_v_u16m1(void* ptr, vuint16m1_t data, size_t vlen) {
    asm volatile(
        "vse16.v %0, (ca0)"
        : // no output (we specify ca0 directly)
        : "vr"(data) // input = vector register
        : "memory"
    );
}

vint16m1_t cheri_vle16_v_i16m1(const void* ptr, size_t vlen) {
    vint16m1_t data;
    asm volatile(
        "vle16.v %0, (ca0)"
        : "=vr"(data) // Vector register output
        : // no extra input (we specify ca0 directly)
    );
    return data;
}

void cheri_vse16_v_i16m1(void* ptr, vint16m1_t data, size_t vlen) {
    asm volatile(
        "vse16.v %0, (ca0)"
        : // no output (we specify ca0 directly)
        : "vr"(data) // input = vector register
        : "memory"
    );
}

vuint32m1_t cheri_vle32_v_u32m1(const void* ptr, size_t vlen) {
    vuint32m1_t data;
    asm volatile(
        "vle32.v %0, (ca0)"
        : "=vr"(data) // Vector register output
        : // no extra input (we specify ca0 directly)
    );
    return data;
}

void cheri_vse32_v_u32m1(void* ptr, vuint32m1_t data, size_t vlen) {
    asm volatile(
        "vse32.v %0, (ca0)"
        : // no output (we specify ca0 directly)
        : "vr"(data) // input = vector register
        : "memory"
    );
}

vint32m1_t cheri_vle32_v_i32m1(const void* ptr, size_t vlen) {
    vint32m1_t data;
    asm volatile(
        "vle32.v %0, (ca0)"
        : "=vr"(data) // Vector register output
        : // no extra input (we specify ca0 directly)
    );
    return data;
}

void cheri_vse32_v_i32m1(void* ptr, vint32m1_t data, size_t vlen) {
    asm volatile(
        "vse32.v %0, (ca0)"
        : // no output (we specify ca0 directly)
        : "vr"(data) // input = vector register
        : "memory"
    );
}

vuint8m2_t cheri_vle8_v_u8m2(const void* ptr, size_t vlen) {
    vuint8m2_t data;
    asm volatile(
        "vle8.v %0, (ca0)"
        : "=vr"(data) // Vector register output
        : // no extra input (we specify ca0 directly)
    );
    return data;
}

void cheri_vse8_v_u8m2(void* ptr, vuint8m2_t data, size_t vlen) {
    asm volatile(
        "vse8.v %0, (ca0)"
        : // no output (we specify ca0 directly)
        : "vr"(data) // input = vector register
        : "memory"
    );
}

vint8m2_t cheri_vle8_v_i8m2(const void* ptr, size_t vlen) {
    vint8m2_t data;
    asm volatile(
        "vle8.v %0, (ca0)"
        : "=vr"(data) // Vector register output
        : // no extra input (we specify ca0 directly)
    );
    return data;
}

void cheri_vse8_v_i8m2(void* ptr, vint8m2_t data, size_t vlen) {
    asm volatile(
        "vse8.v %0, (ca0)"
        : // no output (we specify ca0 directly)
        : "vr"(data) // input = vector register
        : "memory"
    );
}

vuint16m2_t cheri_vle16_v_u16m2(const void* ptr, size_t vlen) {
    vuint16m2_t data;
    asm volatile(
        "vle16.v %0, (ca0)"
        : "=vr"(data) // Vector register output
        : // no extra input (we specify ca0 directly)
    );
    return data;
}

void cheri_vse16_v_u16m2(void* ptr, vuint16m2_t data, size_t vlen) {
    asm volatile(
        "vse16.v %0, (ca0)"
        : // no output (we specify ca0 directly)
        : "vr"(data) // input = vector register
        : "memory"
    );
}

vint16m2_t cheri_vle16_v_i16m2(const void* ptr, size_t vlen) {
    vint16m2_t data;
    asm volatile(
        "vle16.v %0, (ca0)"
        : "=vr"(data) // Vector register output
        : // no extra input (we specify ca0 directly)
    );
    return data;
}

void cheri_vse16_v_i16m2(void* ptr, vint16m2_t data, size_t vlen) {
    asm volatile(
        "vse16.v %0, (ca0)"
        : // no output (we specify ca0 directly)
        : "vr"(data) // input = vector register
        : "memory"
    );
}

vuint32m2_t cheri_vle32_v_u32m2(const void* ptr, size_t vlen) {
    vuint32m2_t data;
    asm volatile(
        "vle32.v %0, (ca0)"
        : "=vr"(data) // Vector register output
        : // no extra input (we specify ca0 directly)
    );
    return data;
}

void cheri_vse32_v_u32m2(void* ptr, vuint32m2_t data, size_t vlen) {
    asm volatile(
        "vse32.v %0, (ca0)"
        : // no output (we specify ca0 directly)
        : "vr"(data) // input = vector register
        : "memory"
    );
}

vint32m2_t cheri_vle32_v_i32m2(const void* ptr, size_t vlen) {
    vint32m2_t data;
    asm volatile(
        "vle32.v %0, (ca0)"
        : "=vr"(data) // Vector register output
        : // no extra input (we specify ca0 directly)
    );
    return data;
}

void cheri_vse32_v_i32m2(void* ptr, vint32m2_t data, size_t vlen) {
    asm volatile(
        "vse32.v %0, (ca0)"
        : // no output (we specify ca0 directly)
        : "vr"(data) // input = vector register
        : "memory"
    );
}

vuint8m4_t cheri_vle8_v_u8m4(const void* ptr, size_t vlen) {
    vuint8m4_t data;
    asm volatile(
        "vle8.v %0, (ca0)"
        : "=vr"(data) // Vector register output
        : // no extra input (we specify ca0 directly)
    );
    return data;
}

void cheri_vse8_v_u8m4(void* ptr, vuint8m4_t data, size_t vlen) {
    asm volatile(
        "vse8.v %0, (ca0)"
        : // no output (we specify ca0 directly)
        : "vr"(data) // input = vector register
        : "memory"
    );
}

vint8m4_t cheri_vle8_v_i8m4(const void* ptr, size_t vlen) {
    vint8m4_t data;
    asm volatile(
        "vle8.v %0, (ca0)"
        : "=vr"(data) // Vector register output
        : // no extra input (we specify ca0 directly)
    );
    return data;
}

void cheri_vse8_v_i8m4(void* ptr, vint8m4_t data, size_t vlen) {
    asm volatile(
        "vse8.v %0, (ca0)"
        : // no output (we specify ca0 directly)
        : "vr"(data) // input = vector register
        : "memory"
    );
}

vuint16m4_t cheri_vle16_v_u16m4(const void* ptr, size_t vlen) {
    vuint16m4_t data;
    asm volatile(
        "vle16.v %0, (ca0)"
        : "=vr"(data) // Vector register output
        : // no extra input (we specify ca0 directly)
    );
    return data;
}

void cheri_vse16_v_u16m4(void* ptr, vuint16m4_t data, size_t vlen) {
    asm volatile(
        "vse16.v %0, (ca0)"
        : // no output (we specify ca0 directly)
        : "vr"(data) // input = vector register
        : "memory"
    );
}

vint16m4_t cheri_vle16_v_i16m4(const void* ptr, size_t vlen) {
    vint16m4_t data;
    asm volatile(
        "vle16.v %0, (ca0)"
        : "=vr"(data) // Vector register output
        : // no extra input (we specify ca0 directly)
    );
    return data;
}

void cheri_vse16_v_i16m4(void* ptr, vint16m4_t data, size_t vlen) {
    asm volatile(
        "vse16.v %0, (ca0)"
        : // no output (we specify ca0 directly)
        : "vr"(data) // input = vector register
        : "memory"
    );
}

vuint32m4_t cheri_vle32_v_u32m4(const void* ptr, size_t vlen) {
    vuint32m4_t data;
    asm volatile(
        "vle32.v %0, (ca0)"
        : "=vr"(data) // Vector register output
        : // no extra input (we specify ca0 directly)
    );
    return data;
}

void cheri_vse32_v_u32m4(void* ptr, vuint32m4_t data, size_t vlen) {
    asm volatile(
        "vse32.v %0, (ca0)"
        : // no output (we specify ca0 directly)
        : "vr"(data) // input = vector register
        : "memory"
    );
}

vint32m4_t cheri_vle32_v_i32m4(const void* ptr, size_t vlen) {
    vint32m4_t data;
    asm volatile(
        "vle32.v %0, (ca0)"
        : "=vr"(data) // Vector register output
        : // no extra input (we specify ca0 directly)
    );
    return data;
}

void cheri_vse32_v_i32m4(void* ptr, vint32m4_t data, size_t vlen) {
    asm volatile(
        "vse32.v %0, (ca0)"
        : // no output (we specify ca0 directly)
        : "vr"(data) // input = vector register
        : "memory"
    );
}

vuint8m8_t cheri_vle8_v_u8m8(const void* ptr, size_t vlen) {
    vuint8m8_t data;
    asm volatile(
        "vle8.v %0, (ca0)"
        : "=vr"(data) // Vector register output
        : // no extra input (we specify ca0 directly)
    );
    return data;
}

void cheri_vse8_v_u8m8(void* ptr, vuint8m8_t data, size_t vlen) {
    asm volatile(
        "vse8.v %0, (ca0)"
        : // no output (we specify ca0 directly)
        : "vr"(data) // input = vector register
        : "memory"
    );
}

vint8m8_t cheri_vle8_v_i8m8(const void* ptr, size_t vlen) {
    vint8m8_t data;
    asm volatile(
        "vle8.v %0, (ca0)"
        : "=vr"(data) // Vector register output
        : // no extra input (we specify ca0 directly)
    );
    return data;
}

void cheri_vse8_v_i8m8(void* ptr, vint8m8_t data, size_t vlen) {
    asm volatile(
        "vse8.v %0, (ca0)"
        : // no output (we specify ca0 directly)
        : "vr"(data) // input = vector register
        : "memory"
    );
}

vuint16m8_t cheri_vle16_v_u16m8(const void* ptr, size_t vlen) {
    vuint16m8_t data;
    asm volatile(
        "vle16.v %0, (ca0)"
        : "=vr"(data) // Vector register output
        : // no extra input (we specify ca0 directly)
    );
    return data;
}

void cheri_vse16_v_u16m8(void* ptr, vuint16m8_t data, size_t vlen) {
    asm volatile(
        "vse16.v %0, (ca0)"
        : // no output (we specify ca0 directly)
        : "vr"(data) // input = vector register
        : "memory"
    );
}

vint16m8_t cheri_vle16_v_i16m8(const void* ptr, size_t vlen) {
    vint16m8_t data;
    asm volatile(
        "vle16.v %0, (ca0)"
        : "=vr"(data) // Vector register output
        : // no extra input (we specify ca0 directly)
    );
    return data;
}

void cheri_vse16_v_i16m8(void* ptr, vint16m8_t data, size_t vlen) {
    asm volatile(
        "vse16.v %0, (ca0)"
        : // no output (we specify ca0 directly)
        : "vr"(data) // input = vector register
        : "memory"
    );
}

vuint32m8_t cheri_vle32_v_u32m8(const void* ptr, size_t vlen) {
    vuint32m8_t data;
    asm volatile(
        "vle32.v %0, (ca0)"
        : "=vr"(data) // Vector register output
        : // no extra input (we specify ca0 directly)
    );
    return data;
}

void cheri_vse32_v_u32m8(void* ptr, vuint32m8_t data, size_t vlen) {
    asm volatile(
        "vse32.v %0, (ca0)"
        : // no output (we specify ca0 directly)
        : "vr"(data) // input = vector register
        : "memory"
    );
}

vint32m8_t cheri_vle32_v_i32m8(const void* ptr, size_t vlen) {
    vint32m8_t data;
    asm volatile(
        "vle32.v %0, (ca0)"
        : "=vr"(data) // Vector register output
        : // no extra input (we specify ca0 directly)
    );
    return data;
}

void cheri_vse32_v_i32m8(void* ptr, vint32m8_t data, size_t vlen) {
    asm volatile(
        "vse32.v %0, (ca0)"
        : // no output (we specify ca0 directly)
        : "vr"(data) // input = vector register
        : "memory"
    );
}
#endif // __has_feature(capabilities)
#endif // CHERI_VECTOR_WRAPPERS